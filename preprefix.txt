;; Boolean literals 
(define true (= 1 1))
(define false (= 1 0))
(define #t true)
(define #f false)

;; Streams
;; See mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html
(define (force u) (u))
(define stream-car car)
(define (stream-cdr s) (force (cdr s)))
(define stream-null? null?)
(define the-empty-stream '())

;; List stuff
;; `length' - r6rs.pdf, page 48
(define (length list)
   (define (iter acc list)
      (cond
         ((null? list) acc)
         ((pair? list)
            (iter (+ acc 1) (cdr list)))
         (else acc)))
   (iter 0 list))

;; `list-tail' - r6rs.pdf, page 48
(define (list-tail list k)
   (if (>= (length list) k)
      (begin
         (define (iter p c)
            (if (= c 0)
               p
               (iter (cdr p) (- c 1))))
         (iter list k))
      '()))

;; `append' - r6rs.pdf, page 48
;; ]=> (append '(a b) 'c '(d e f) '(g h) 'i)
;; (a b c d e f g h i)
(define append
   (begin
      ;; 2-argument implementation
      (define (append2 a b)
         (cond
            ((null? a) b)
            ((pair? a)
               (cons (car a) (append2 (cdr a) b)))
            (else
               (cons a (append2 '() b)))))

      ;; do a right-fold of append2 on the args
      (lambda args
         (define (iter l)
            (if (null? l)
               '()
	        (append2 (car l) (iter (cdr l)))))
         (iter args))))

;; `reverse' - r6rs.pdf, page 48
(define (reverse list)
   (cond
      ((pair? list)
         (append (reverse (cdr list)) (list (car list))))
      (else
         ;; meh
         list)))

;; `list-ref' - r6rs.pdf, page 48
(define (list-ref list k)
   (if (>= (length list) (+ k 1))
      (begin
         (define (iter count list)
            (if (= count k)
               (car list)
               (iter (+ count 1) (cdr list))))
         (iter 0 list))
      '()))

