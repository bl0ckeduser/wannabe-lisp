#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include "wannabe-lisp.h"

int interactive;	/* interactive (repl) mode flag */
env_t *global;		/* pointer to global environment */
jmp_buf repl_jmp;	/* jump pointer to REPL used to 
					 * recover from in-code errors */
int save_mode = 0;	/* logging-to-file mode flag */
FILE *save_file;	/* log file handle */

void final_clean_up()
{
	gc();
	gc_selfdestroy();
}

int main(int argc, char **argv)
{
	char *buf = malloc(1024 * 512);
	char out[1024];
	list_t *expr;

	/* Setup the debug-output-log module.
	 * Must make sure to run this before running
	 * the prefix-loading code, because that goes
	 * through the interpreter, which pushes 
	 * debug data */
	stacktracer_init();

	/* Always good to initialize strings, otherwise strange
	 * random garbage appears when you least expect it. */
	*buf = 0;

	/* Create the global environment */
	global = new_env();

	/* Set up the built-in procedure symbols 
	 * for arithmetic, comparisons, etc. These
	 * map to code written in C that is within
	 * the interpreter itself (in `primitives.c'). */
	install_primitives(global);

	/* Load up some composite primitives, stored
	 * in the file `prefix.txt', which is Scheme code. 
	 * `prefix.txt' is partly hand-written (`preprefix.txt'),
	 * and partly generated by the script `gen-prefix.py'. */
	load_code_from_file("prefix.txt");

	/* Check for a "./lisp -i" invocation -- 
	 * that means interactive mode */
	interactive = argc == 2 && !strcmp(argv[1], "-i");

	/* In interactive mode, code errors jump to here.
	 * If the user writes invalid code, the program
	 * does not exit but rather gives a new fresh prompt
	 * (and also makes debug logs etc. available upon
	 * request) */
	if (setjmp(repl_jmp))
		*buf = 0;
	stacktracer_reset();

	/* This `while' is the REPL */
	while (1) {	
		/* Clean up `buf', which holds input lines,
		 * and clean up `expr', which is the structure
		 * to which input gets parsed 
		 */
		*buf = 0;
		expr = new_list();

		/* The flag GC_STRESS_TEST causes the program
		 * to constantly repeat the same code in a loop.
		 * Because the GC is in reasonable working order,
		 * the host machine will *not* run out of memory
		 * after a minute or so.
		 */
#ifdef GC_STRESS_TEST
		sprintf(buf, "((lambda (x) x) (+ 1 2 3))");
#else
		if (save_mode)
			fprintf(save_file, "\n");

		/* Read a syntactic/logical, i.e. parenthesis-complete
		 * "line". do_read(), owned by `linereader.c', waits
		 * for the user to close all parentheses even
		 * if it takes several input-lines. */
		if (!do_read_file(buf, stdin, interactive))
			break;
#endif

		if (!*buf)
			break;

		/* Parse the input string into a tree */
		build(expr, buf);

		/* arghhh -- in other words, this is what was
		 * left behind after some painful debugging */
		if (feof(stdin))
			break;

		/* Evaluate the parsed input and print the result */
		if (interactive) {
			*out = 0;
			printout(call_eval(expr, global), out);
			puts(out);

			/* If log mode set, log REPL 
			 * printback as a comment */
			if (save_mode) {
				fprintf(save_file, ";; ");
				fflush(save_file);
				fputs(out, save_file);
				fprintf(save_file, "\n");
			}
		} else {
			/* In non-interactive mode, don't print the
			 * result. (You can use `display' to print
			 * things then). */
			call_eval(expr, global);
		}

		/* Clean up leftover goo */
		gc();

		/* Clear debug trace after every input line */
		stacktracer_reset();
	}

	/* clean up lots of stuff */
	if (save_mode)
		fclose(save_file);
	final_clean_up();
	free(buf);
	stacktracer_destroy();

	return 0;
}
